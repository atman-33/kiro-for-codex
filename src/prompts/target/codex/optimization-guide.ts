// Auto-generated from src/prompts/codex/optimization-guide.md
// DO NOT EDIT MANUALLY

export const frontmatter = {};

export const content = "# Codex CLI Prompt Optimization Guide\n\nThis guide provides comprehensive instructions for optimizing prompts for Codex CLI to ensure maximum effectiveness in code generation and task execution.\n\n## Core Optimization Principles\n\n### 1. Clarity and Specificity\n- Use precise, unambiguous language\n- Avoid vague or interpretive instructions\n- Provide specific examples and patterns\n- Include concrete success criteria\n- Define clear boundaries and constraints\n\n### 2. Structured Information Hierarchy\n- Organize information in logical sections\n- Use consistent formatting patterns\n- Provide clear section headers\n- Structure complex information hierarchically\n- Enable easy parsing and navigation\n\n### 3. Context Completeness\n- Include all necessary background information\n- Provide relevant codebase context\n- Reference existing patterns and conventions\n- Include integration requirements\n- Specify environmental constraints\n\n### 4. Actionable Instructions\n- Focus on specific, executable tasks\n- Provide step-by-step guidance\n- Include validation checkpoints\n- Specify expected outcomes\n- Enable incremental progress\n\n## Codex CLI Specific Optimizations\n\n### Command Structure Optimization\n```markdown\n# Optimal Command Structure\n\n## Task: [Clear, Specific Task Name]\n\n## Context\n[Complete context with all necessary background]\n\n## Objective\n[Specific, measurable objective]\n\n## Constraints\n[Clear constraints and requirements]\n\n## Expected Output\n[Detailed description of expected results]\n\n## Implementation Guidance\n[Specific implementation instructions]\n\n## Validation Criteria\n[Clear success criteria and validation steps]\n```\n\n### Code Generation Optimization\n```markdown\n# Code Generation Best Practices\n\n## Interface Definitions (Functional Approach)\n```typescript\n// Always provide complete interface definitions using functional patterns\ninterface ComponentInterface {\n    readonly process: (param: Type) => ReturnType;\n    readonly validate: (param1: Type1, param2: Type2) => Promise<ValidationResult>;\n    readonly transform: (data: InputType) => OutputType;\n}\n```\n\n## Implementation Patterns (Functional)\n```typescript\n// Provide clear functional implementation patterns\nconst createComponentImplementation = (\n    config: ComponentConfig\n): ComponentInterface => ({\n    process: (param) => {\n        // Include comprehensive error handling\n        // Follow functional programming principles\n        // Use immutable operations\n        return processWithConfig(param, config);\n    },\n    \n    validate: async (param1, param2) => {\n        // Functional validation approach\n        const validationRules = getValidationRules(config);\n        return validateParams(param1, param2, validationRules);\n    },\n    \n    transform: (data) => {\n        // Pure function transformation\n        return pipe(\n            normalizeData,\n            applyBusinessRules,\n            formatOutput\n        )(data);\n    }\n});\n\n// Use classes only when absolutely necessary\nclass ComplexStatefulComponent implements ComponentInterface {\n    private readonly state: ComponentState;\n    \n    constructor(initialState: ComponentState) {\n        this.state = initialState;\n    }\n    \n    // Use arrow functions for methods\n    public readonly process = (param: Type): ReturnType => {\n        // Implementation with state management\n    };\n}\n```\n\n## Testing Patterns (Functional)\n```typescript\n// Include comprehensive testing patterns for functional code\ndescribe('ComponentImplementation', () => {\n    const mockConfig = createMockConfig();\n    const component = createComponentImplementation(mockConfig);\n    \n    describe('process', () => {\n        it('should process data immutably', () => {\n            const input = createTestInput();\n            const result = component.process(input);\n            \n            // Verify input wasn't mutated\n            expect(input).toEqual(createTestInput());\n            expect(result).toEqual(expectedOutput);\n        });\n    });\n    \n    // Test pure functions separately\n    describe('utility functions', () => {\n        it('should transform data predictably', () => {\n            const input = createTestData();\n            const result = transformData(input);\n            \n            // Pure function should always return same output for same input\n            expect(result).toEqual(transformData(input));\n        });\n    });\n});\n```\n```\n\n### Error Handling Optimization\n```markdown\n# Error Handling Patterns\n\n## Error Type Definitions\n```typescript\n// Define specific error types\nclass ValidationError extends Error {\n    constructor(message: string, public details: ValidationDetails) {\n        super(message);\n        this.name = 'ValidationError';\n    }\n}\n```\n\n## Error Handling Implementation\n```typescript\n// Implement comprehensive error handling\ntry {\n    // Main logic implementation\n} catch (error) {\n    // Specific error handling based on error type\n    // Appropriate logging and monitoring\n    // User-friendly error responses\n}\n```\n```\n\n## Prompt Structure Templates\n\n### Basic Task Template\n```markdown\n---\nid: [unique-id]\nname: [Human Readable Name]\nversion: [version-number]\ndescription: [Brief description of the prompt's purpose]\nvariables:\n  [variable-name]:\n    type: [string|number|boolean]\n    required: [true|false]\n    description: [Description of the variable]\n---\n\n# Task: [Task Name]\n\n## Context\n[Comprehensive context including background, current state, and objectives]\n\n## Requirements\n- [Requirement 1]: [Specific, measurable requirement]\n- [Requirement 2]: [Specific, measurable requirement]\n- [Requirement 3]: [Specific, measurable requirement]\n\n## Constraints\n- [Constraint 1]: [Specific limitation or requirement]\n- [Constraint 2]: [Specific limitation or requirement]\n\n## Expected Output\n[Detailed description of expected results with examples]\n\n## Implementation Guidelines\n[Specific guidance for implementation including patterns and best practices]\n\n## Validation Criteria\n- [ ] [Validation criterion 1]\n- [ ] [Validation criterion 2]\n- [ ] [Validation criterion 3]\n\n## Success Criteria\n[Clear definition of successful completion]\n```\n\n### Complex Implementation Template\n```markdown\n# Task: [Complex Task Name]\n\n## Overview\n[High-level overview of the task and its importance]\n\n## Context Analysis\n### Current State\n[Description of current system state]\n\n### Target State\n[Description of desired end state]\n\n### Gap Analysis\n[What needs to be implemented to bridge the gap]\n\n## Requirements Breakdown\n### Functional Requirements\n1. [Functional requirement 1]\n2. [Functional requirement 2]\n\n### Non-Functional Requirements\n1. [Performance requirement]\n2. [Security requirement]\n3. [Maintainability requirement]\n\n## Architecture Considerations\n### Component Design\n[How components should be structured]\n\n### Interface Definitions\n[Required interfaces and contracts]\n\n### Integration Points\n[How this integrates with existing systems]\n\n## Implementation Strategy\n### Phase 1: [Phase Name]\n[Detailed implementation steps for this phase]\n\n### Phase 2: [Phase Name]\n[Detailed implementation steps for this phase]\n\n## Testing Strategy\n### Unit Testing\n[Unit testing requirements and patterns]\n\n### Integration Testing\n[Integration testing requirements]\n\n### End-to-End Testing\n[E2E testing requirements]\n\n## Quality Assurance\n### Code Quality Standards\n[Specific quality requirements]\n\n### Performance Requirements\n[Performance benchmarks and requirements]\n\n### Security Requirements\n[Security considerations and requirements]\n\n## Validation Framework\n[Comprehensive validation approach]\n```\n\n## TypeScript Functional Programming Guidelines\n\n### Core Principles\n1. **Functional Programming First**: Prefer functional patterns over object-oriented approaches\n2. **Arrow Functions Preferred**: Use arrow functions for better readability and lexical scoping\n3. **Classes Only When Necessary**: Use classes only for complex state management or when absolutely required\n4. **Immutability**: Favor immutable data structures and pure functions\n5. **Composition Over Inheritance**: Build functionality through composition rather than class hierarchies\n\n### Function Definition Patterns\n```typescript\n// ✅ Preferred: Arrow functions with explicit types\nconst processUser = (user: User): ProcessedUser => {\n    return {\n        ...user,\n        processedAt: new Date(),\n        status: 'processed'\n    };\n};\n\n// ✅ For complex functions with multiple operations\nconst validateAndProcessUsers = (users: User[]): Result<ProcessedUser[], ValidationError> => {\n    const validUsers = users.filter(isValidUser);\n    const processedUsers = validUsers.map(processUser);\n    \n    return validUsers.length === users.length\n        ? success(processedUsers)\n        : error(new ValidationError('Some users failed validation'));\n};\n\n// ❌ Avoid: Traditional function declarations\nfunction processUser(user: User): ProcessedUser {\n    // Less preferred approach\n}\n\n// ❌ Avoid: Classes for simple operations\nclass UserProcessor {\n    process(user: User): ProcessedUser {\n        // Unnecessary class for simple operation\n    }\n}\n```\n\n### When to Use Classes\nClasses should only be used in these specific scenarios:\n\n```typescript\n// ✅ Acceptable: Complex state management with multiple related methods\nclass StateMachine {\n    private state: MachineState;\n    private history: StateTransition[];\n    \n    constructor(initialState: MachineState) {\n        this.state = initialState;\n        this.history = [];\n    }\n    \n    // Use arrow functions for methods to maintain 'this' binding\n    public transition = (event: StateEvent): void => {\n        const previousState = this.state;\n        this.state = this.calculateNextState(event);\n        this.history.push({ from: previousState, to: this.state, event });\n    };\n    \n    public canTransition = (event: StateEvent): boolean => {\n        return this.getValidTransitions().includes(event);\n    };\n}\n\n// ✅ Acceptable: Implementing interfaces that require instance methods\nclass DatabaseConnection implements Connection {\n    private pool: ConnectionPool;\n    \n    constructor(config: DatabaseConfig) {\n        this.pool = createPool(config);\n    }\n    \n    public query = async <T>(sql: string, params: unknown[]): Promise<T[]> => {\n        // Implementation\n    };\n}\n\n// ❌ Avoid: Simple data processing that can be functional\nclass MathUtils {\n    static add(a: number, b: number): number {\n        return a + b; // This should just be a function\n    }\n}\n```\n\n### Composition Patterns\n```typescript\n// ✅ Preferred: Composition with functions\ninterface UserService {\n    validate: (user: User) => ValidationResult;\n    process: (user: User) => ProcessedUser;\n    save: (user: ProcessedUser) => Promise<void>;\n}\n\nconst createUserService = (\n    validator: UserValidator,\n    processor: UserProcessor,\n    repository: UserRepository\n): UserService => ({\n    validate: (user) => validator.validate(user),\n    process: (user) => processor.process(user),\n    save: (user) => repository.save(user)\n});\n\n// ✅ Function composition for complex operations\nconst processUserPipeline = (user: User): Promise<ProcessedUser> => {\n    return pipe(\n        validateUser,\n        transformUser,\n        enrichUser,\n        saveUser\n    )(user);\n};\n```\n\n### Immutability Patterns\n```typescript\n// ✅ Preferred: Immutable updates\nconst updateUserStatus = (user: User, status: UserStatus): User => ({\n    ...user,\n    status,\n    updatedAt: new Date()\n});\n\n// ✅ Immutable array operations\nconst addUserToList = (users: User[], newUser: User): User[] => [\n    ...users,\n    newUser\n];\n\nconst removeUserFromList = (users: User[], userId: string): User[] =>\n    users.filter(user => user.id !== userId);\n\n// ❌ Avoid: Mutating objects directly\nconst updateUserStatusMutable = (user: User, status: UserStatus): void => {\n    user.status = status; // Mutates the original object\n    user.updatedAt = new Date();\n};\n```\n\n### Error Handling with Functional Patterns\n```typescript\n// ✅ Preferred: Result/Either pattern for error handling\ntype Result<T, E> = Success<T> | Failure<E>;\n\ninterface Success<T> {\n    readonly kind: 'success';\n    readonly value: T;\n}\n\ninterface Failure<E> {\n    readonly kind: 'failure';\n    readonly error: E;\n}\n\nconst success = <T>(value: T): Success<T> => ({ kind: 'success', value });\nconst failure = <E>(error: E): Failure<E> => ({ kind: 'failure', error });\n\nconst processUserSafely = (user: User): Result<ProcessedUser, ProcessingError> => {\n    try {\n        const processed = processUser(user);\n        return success(processed);\n    } catch (error) {\n        return failure(new ProcessingError(error.message));\n    }\n};\n```\n\n## Language and Style Guidelines\n\n### Technical Writing Best Practices\n- Use active voice for instructions\n- Be concise while maintaining completeness\n- Use consistent terminology throughout\n- Avoid jargon unless necessary and defined\n- Structure sentences for easy parsing\n\n### TypeScript Best Practices\n```typescript\n// Prefer functional programming patterns over object-oriented\n// Use arrow functions for better readability and lexical scoping\nconst processData = (data: InputType[]): OutputType[] => {\n    return data\n        .filter(item => item.isValid)\n        .map(item => transformItem(item))\n        .sort((a, b) => a.priority - b.priority);\n};\n\n// Use classes only when absolutely necessary (e.g., for complex state management)\n// Prefer composition over inheritance\ninterface DataProcessor {\n    process: (data: InputType) => OutputType;\n    validate: (data: InputType) => boolean;\n}\n\nconst createDataProcessor = (config: ProcessorConfig): DataProcessor => ({\n    process: (data) => {\n        // Functional implementation\n        return processWithConfig(data, config);\n    },\n    validate: (data) => validateData(data, config.rules)\n});\n\n// Avoid classes unless they provide clear benefits\n// Only use classes for:\n// 1. Complex state management with multiple related methods\n// 2. When implementing interfaces that require instance methods\n// 3. When inheritance provides clear architectural benefits\nclass ComplexStateMachine {\n    private state: MachineState;\n    \n    constructor(initialState: MachineState) {\n        this.state = initialState;\n    }\n    \n    // Use arrow functions for methods to maintain 'this' binding\n    public transition = (event: StateEvent): void => {\n        this.state = this.calculateNextState(event);\n    };\n}\n```\n\n### Code Documentation Standards\n```typescript\n/**\n * Comprehensive JSDoc comment explaining the function\n * @param param1 - Clear description of parameter\n * @param param2 - Clear description of parameter\n * @returns Clear description of return value\n * @throws {ErrorType} Description of when this error is thrown\n * @example\n * // Clear usage example with functional approach\n * const result = processFunction(param1, param2);\n */\nconst processFunction = (param1: Type1, param2: Type2): ReturnType => {\n    // Implementation with clear inline comments\n    // Prefer immutable operations and pure functions\n};\n```\n\n### Error Message Guidelines\n```typescript\n// Good error messages are specific and actionable\nthrow new ValidationError(\n    'Invalid email format provided',\n    {\n        field: 'email',\n        value: providedEmail,\n        expectedFormat: 'user@domain.com',\n        validationRule: 'RFC 5322 compliant email address'\n    }\n);\n```\n\n## Approval Mode Specific Optimizations\n\n### Interactive Mode Optimizations\n- Break complex tasks into smaller, reviewable steps\n- Include clear progress indicators\n- Provide detailed explanations for each step\n- Use checkpoint questions for user feedback\n- Preview next steps to maintain context\n\n### Auto-Edit Mode Optimizations\n- Provide complete context upfront\n- Minimize ambiguous requirements\n- Include comprehensive implementation guidance\n- Focus on self-contained, complete implementations\n- Provide clear success criteria\n\n### Full-Auto Mode Optimizations\n- Include all requirements and constraints upfront\n- Provide comprehensive specifications\n- Anticipate edge cases and error scenarios\n- Include complete validation framework\n- Ensure production-ready output\n\n## Performance Optimization Guidelines\n\n### Prompt Efficiency\n- Structure information for quick parsing\n- Use clear section headers and formatting\n- Minimize redundant information\n- Focus on essential details\n- Optimize for Codex CLI processing patterns\n\n### Code Generation Efficiency\n- Provide clear patterns and examples\n- Include comprehensive type definitions\n- Specify integration requirements clearly\n- Include performance considerations\n- Optimize for maintainability\n\n### Testing Efficiency\n- Provide clear testing patterns\n- Include comprehensive test coverage requirements\n- Specify mock and stub patterns\n- Include performance testing requirements\n- Optimize for continuous integration\n\n## Quality Assurance Framework\n\n### Prompt Quality Checklist\n- [ ] Clear, specific task definition\n- [ ] Comprehensive context provided\n- [ ] All requirements clearly specified\n- [ ] Constraints and limitations defined\n- [ ] Expected output clearly described\n- [ ] Implementation guidance provided\n- [ ] Validation criteria specified\n- [ ] Success criteria defined\n- [ ] Approval mode optimizations applied\n- [ ] Code examples are complete and correct\n\n### Implementation Quality Standards\n- [ ] Code follows existing patterns\n- [ ] Error handling is comprehensive\n- [ ] Testing coverage is adequate\n- [ ] Documentation is complete\n- [ ] Performance requirements met\n- [ ] Security considerations addressed\n- [ ] Integration requirements satisfied\n- [ ] Validation criteria met\n\n### Validation Framework\n- [ ] All requirements implemented\n- [ ] All tests passing\n- [ ] Code quality standards met\n- [ ] Integration successful\n- [ ] Performance benchmarks achieved\n- [ ] Security requirements satisfied\n- [ ] Documentation complete and accurate\n- [ ] User acceptance criteria met\n\n## Best Practices Summary\n\n### Do's\n- Use clear, specific language\n- Provide comprehensive context\n- Include concrete examples\n- Structure information hierarchically\n- Optimize for the target approval mode\n- Include comprehensive validation criteria\n- Follow existing codebase patterns\n- Implement robust error handling\n- **TypeScript Specific:**\n  - Prefer functional programming patterns over object-oriented\n  - Use arrow functions for better readability and lexical scoping\n  - Favor composition over inheritance\n  - Use immutable data structures and pure functions\n  - Implement type-safe error handling with Result/Either patterns\n\n### Don'ts\n- Use vague or ambiguous language\n- Omit important context or constraints\n- Provide incomplete examples\n- Mix different approval mode patterns\n- Skip validation or testing requirements\n- Ignore existing codebase conventions\n- Implement minimal error handling\n- Forget to include success criteria\n- **TypeScript Specific:**\n  - Don't use classes unless absolutely necessary\n  - Avoid traditional function declarations in favor of arrow functions\n  - Don't mutate objects directly - use immutable patterns\n  - Avoid inheritance hierarchies - prefer composition\n  - Don't ignore TypeScript's strict type checking capabilities\n\n### Continuous Improvement\n- Regularly review and update prompt templates\n- Gather feedback on prompt effectiveness\n- Monitor code generation quality\n- Optimize based on usage patterns\n- Update for new Codex CLI features\n- Maintain consistency across all prompts\n- Document lessons learned and best practices";

export default {
  frontmatter,
  content
};
